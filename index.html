<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>避けて！ロケット！</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --main-color: #e0e0e0;
            --accent-color: #ff2e63;
            --secondary-color: #08d9d6;
            --success-color: #3f72af;
            --danger-color: #d83a56;
            --warning-color: #f7a400;
            --font-family: 'Inter', sans-serif;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        body {
            background-color: var(--bg-color);
            color: var(--main-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: 100dvh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        canvas {
            background-color: transparent;
            touch-action: none;
            display: block;
        }

        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .ui-element, .skill-button {
            pointer-events: none;
        }
        .ui-container.is-active .ui-element,
        .ui-container.is-active .skill-button {
            pointer-events: auto;
        }

        .top-ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
        }

        .bottom-ui {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        .left-ui, .right-ui {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .left-ui {
            left: 1rem;
            gap: 1rem;
        }
        
        .right-ui {
            top: auto;
            transform: none;
            bottom: 2rem;
            right: 2rem;
        }


        .ui-element {
            padding: 0.5rem 1rem;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.2rem;
            transition: opacity 0.5s ease-in-out;
        }
        #pause-button {
            background-color: rgba(216, 216, 216, 0.5);
        }

        .ui-element.score {
            font-size: 3rem;
            background: none;
            box-shadow: none;
        }

        .ui-element.lives {
            display: flex;
            gap: 0.5rem;
            background: none;
            box-shadow: none;
        }

        .life-icon {
            font-size: 1.5rem;
            color: var(--secondary-color);
        }

        .skill-button {
            width: 50px;
            height: 50px;
            background-color: var(--bg-color);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--border-radius);
            position: relative;
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.1s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .skill-button:active {
            transform: scale(0.95);
        }

        .skill-button .icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.3);
            z-index: 2;
        }

        .charge-meter {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: conic-gradient(var(--secondary-color) 0%, transparent 0%);
            z-index: 1;
        }

        .skill-button.ready .icon {
            color: var(--accent-color);
        }

        .skill-button.ready .charge-meter {
            background: var(--accent-color);
            opacity: 0.8;
        }

        .skill-key {
            position: absolute;
            bottom: 2px;
            right: 5px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1rem;
            font-weight: bold;
            z-index: 3;
            pointer-events: none;
        }
        
        .skill-button.ready .skill-key {
            color: white;
        }
        
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0s 0.5s;
            pointer-events: none;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.5s ease-in-out;
        }
        
        .modal-content {
            background-color: rgba(26, 26, 46, 0.9);
            border-radius: var(--border-radius);
            padding: 2rem;
            text-align: center;
            transform: scale(0.8);
            opacity: 0;
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            width: 400px;
        }
        
        .modal-overlay.visible .modal-content {
            transform: scale(1);
            opacity: 1;
        }
        
        .modal-title {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        .modal-buttons {
            margin-top: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .modal-buttons button {
            width: 100%;
        }

        .modal-text {
            margin-bottom: 1rem;
        }

        .modal-button {
            padding: 0.75rem 1.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--main-color);
            background-color: var(--secondary-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .modal-button:hover {
            background-color: var(--accent-color);
        }

        .modal-button:active {
            transform: scale(0.98);
        }

        .toggle-switch-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1rem 0;
        }

        .toggle-switch-container label {
            font-size: 1.1rem;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--secondary-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
            pointer-events: auto;
            opacity: 1;
            transition: opacity 1s ease-in-out;
            cursor: pointer;
        }

        #title-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #game-title {
            font-size: 3rem;
            text-align: center;
            margin: 0;
        }

        #player-icon-title {
            font-size: 8rem;
            color: var(--secondary-color);
            animation: pulse 2s infinite ease-in-out;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        #tap-to-screen {
            font-size: 1.5rem;
            margin: 0;
        }

        #high-scores {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 1rem;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        #high-scores h3 {
            margin: 0;
            font-size: 1.5rem;
            color: var(--secondary-color);
        }

        .high-score-item {
            font-size: 1.2rem;
            text-align: center;
            min-width: 150px;
        }
        
        #settings-button-title {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            font-size: 2rem;
            padding: 0.5rem;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.2s;
            box-shadow: var(--box-shadow);
        }

        #settings-button-title:active {
            transform: scale(0.9);
        }
        
        #game-over-modal h2 {
            font-size: 2.5rem;
            color: var(--accent-color);
            margin-bottom: 1rem;
        }

        #game-over-modal p {
            font-size: 1.5rem;
            margin: 0.5rem 0;
        }

        #game-over-modal .tips-text {
            font-size: 1.0rem;
            color: rgb(255, 248, 152);
            margin-top: 1.5rem;
            margin-bottom: 0;
            min-height: 2em;
            font-weight: normal;
            line-height: 1.4;
        }

        .skill-usage-container {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .skill-usage-item {
            text-align: center;
        }

        .skill-usage-icon {
            font-size: 2rem;
        }
        
        #message-box-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        #message-box {
            background: var(--bg-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        /* ▼▼▼▼▼ ここからレスポンシブ対応の修正 ▼▼▼▼▼ */

        /* ===== スマートフォン共通のスタイル ===== */
        @media (max-width: 768px) {
            /* --- タイトル画面 --- */
            #game-title {
                font-size: 2.2rem; /* タイトルフォントを約1/3に変更 */
            }

            #title-screen {
                justify-content: flex-start; /* 上寄せに */
                padding-top: 10%; /* 上部の余白を確保 */
                gap: 1rem; /* 各要素の隙間を調整 */
            }

            #player-icon-title {
                font-size: 6rem; /* ロケットアイコンも少し小さく */
            }

            #high-scores {
                bottom: 20%; /* 画面下端に合わせる */
                width: 40%;
                padding: 0.5rem;
            }
            #settings-button-title {
                bottom: 10%;
            }

            #high-scores h3 {
                font-size: 1rem; /* ハイスコア見出しフォントを約2/3に */
            }

            .high-score-item {
                font-size: 0.9rem; /* ハイスコア項目フォントを約2/3に */
                min-width: 40%;
            }

            /* --- ゲーム中 --- */
            .ui-element.score {
                font-size: 1.5rem; /* スコアフォントを半分に */
            }
        }

        /* ===== スマートフォン横持ち画面のスタイル ===== */
        /* iPhone SE/Pro Maxなどの横画面を想定 */
        @media (max-height: 500px) and (orientation: landscape) {
            
            /* --- タイトル画面 --- */
            #high-scores {
                width: 40%;
                max-width: 200px;
                left: 10rem; /* 左下に表示 */
                bottom: 1rem;
                border-radius: var(--border-radius);
            }
            
            /* --- ゲームオーバーモーダル --- */
            #game-over-modal.modal-content {
                max-height: 95vh; /* 最大高さを画面の高さに合わせる */
                overflow-y: auto; /* コンテンツがはみ出た場合にスクロール */
                padding: 0.5rem 1rem;
            }

            #game-over-modal h2 {
                font-size: 1.25rem; /* テキストフォントを1/2に */
                margin-top: 2px; /* 上の余白を2pxに */
                margin-bottom: 5px; /* 表示物間のgapを5pxに(マージンで調整) */
            }

            #game-over-modal p {
                font-size: 1rem; /* 経過時間・スコアフォントを2/3に */
                margin: 5px 0; /* 表示物間のgapを5pxに(マージンで調整) */
            }

            #game-over-modal .tips-text,
            #game-over-modal .skill-usage-container,
            #game-over-modal .modal-buttons {
                margin-top: 5px; /* 表示物間のgapを5pxに(マージンで調整) */
            }
             #game-over-modal .modal-buttons {
                gap: 5px;
             }


            /* --- 設定モーダル・ポーズモーダル --- */
            #settings-modal .modal-title,
            #pause-modal .modal-title {
                font-size: 1rem; /* 見出しフォントを1/2に */
            }
            #settings-modal .toggle-switch-container,
            #pause-modal .toggle-switch-container {
                 margin: 0.5rem 0;
            }
        }
        /* ▲▲▲▲▲ ここまでレスポンシブ対応の修正 ▲▲▲▲▲ */

    </style>
</head>
<body>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="title-screen">
            <h1 id="game-title">避けて！ロケット！</h1>
            <i class="fas fa-rocket" id="player-icon-title"></i>
            <p id="tap-to-screen">tap to screen</p>
            <div id="high-scores">
                <h3>ハイスコア</h3>
                <div class="high-score-item" id="high-score-1">1. ---</div>
                <div class="high-score-item" id="high-score-2">2. ---</div>
                <div class="high-score-item" id="high-score-3">3. ---</div>
            </div>
            <i class="fas fa-cog" id="settings-button-title"></i>
        </div>

        <div id="game-ui" class="ui-container" style="opacity: 0; pointer-events: none;">
            <div class="top-ui">
                <div class="ui-element time">
                    <i class="fas fa-hourglass-half"></i>
                    <span id="game-time">00:00:00</span>
                </div>
                <div class="ui-element lives" id="lives-display">
                </div>
            </div>
            <div class="bottom-ui">
                <div class="ui-element score">
                    <span id="current-score">0</span>
                </div>
            </div>
            <div class="left-ui">
                <button class="skill-button" id="skill-eraser" data-skill="eraser" disabled>
                    <div class="charge-meter"></div>
                    <i class="fas fa-eraser icon"></i>
                    <span class="skill-key">A</span>
                </button>
                <button class="skill-button" id="skill-boost" data-skill="boost" disabled>
                    <div class="charge-meter"></div>
                    <i class="fas fa-fire-extinguisher icon"></i>
                    <span class="skill-key">S</span>
                </button>
                <button class="skill-button" id="skill-bomb" data-skill="bomb" disabled>
                    <div class="charge-meter"></div>
                    <i class="fas fa-bomb icon"></i>
                    <span class="skill-key">D</span>
                </button>
            </div>
            <div class="right-ui">
                <button class="ui-element" id="pause-button">
                    <i class="fas fa-pause"></i>
                </button>
            </div>
        </div>

        <div id="settings-modal-overlay" class="modal-overlay">
            <div id="settings-modal" class="modal-content">
                <h2 class="modal-title">設定</h2>
                <div class="toggle-switch-container">
                    <label>SE</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="se-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="toggle-switch-container">
                    <label>BGM</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="bgm-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="modal-buttons">
                    <button class="modal-button" id="close-settings-button">閉じる</button>
                </div>
            </div>
        </div>

        <div id="pause-modal-overlay" class="modal-overlay">
            <div id="pause-modal" class="modal-content">
                <h2 class="modal-title">一時停止</h2>
                <div class="modal-buttons">
                    <button class="modal-button" id="resume-button">再開</button>
                    <button class="modal-button" id="game-end-button">ゲーム終了</button>
                </div>
            </div>
        </div>
        
        <div id="game-over-modal-overlay" class="modal-overlay">
            <div id="game-over-modal" class="modal-content">
                <h2>ゲームオーバー</h2>
                <p>経過時間: <span id="game-over-time">00:00:00</span></p>
                <p>スコア: <span id="game-over-score">0</span></p>
                <p id="game-over-tips" class="tips-text"></p>
                <div class="skill-usage-container" id="game-over-skill-usage">
                </div>
                <div class="modal-buttons">
                    <button class="modal-button" id="game-over-return-button">タイトルへ</button>
                </div>
            </div>
        </div>
        
        <div id="message-box-overlay">
            <div id="message-box">
                <p id="message-box-text"></p>
                <button class="modal-button" id="message-box-ok">OK</button>
            </div>
        </div>
        
    </div>

    <script>
        // DOM要素の取得
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const titleScreen = document.getElementById('title-screen');
        const gameUI = document.getElementById('game-ui');
        const highScoresDisplay = document.getElementById('high-scores');
        const highScoresList = [
            document.getElementById('high-score-1'),
            document.getElementById('high-score-2'),
            document.getElementById('high-score-3')
        ];
        const settingsButtonTitle = document.getElementById('settings-button-title');
        const settingsModalOverlay = document.getElementById('settings-modal-overlay');
        const closeSettingsButton = document.getElementById('close-settings-button');
        const pauseButton = document.getElementById('pause-button');
        const pauseModalOverlay = document.getElementById('pause-modal-overlay');
        const gameOverModalOverlay = document.getElementById('game-over-modal-overlay');
        const gameOverReturnButton = document.getElementById('game-over-return-button');
        const seToggle = document.getElementById('se-toggle');
        const bgmToggle = document.getElementById('bgm-toggle');
        
        const currentScoreDisplay = document.getElementById('current-score');
        const gameTimeDisplay = document.getElementById('game-time');
        const livesDisplay = document.getElementById('lives-display');
        const gameOverTimeDisplay = document.getElementById('game-over-time');
        const gameOverScoreDisplay = document.getElementById('game-over-score');
        const gameOverSkillUsageDisplay = document.getElementById('game-over-skill-usage');
        const gameOverTipsDisplay = document.getElementById('game-over-tips');

        const skillEraserBtn = document.getElementById('skill-eraser');
        const skillBoostBtn = document.getElementById('skill-boost');
        const skillBombBtn = document.getElementById('skill-bomb');

        const GAME_STATE = { TITLE: 'title', PLAYING: 'playing', PAUSED: 'paused', GAME_OVER: 'gameOver' };
        const initialPlayerRadius = 10;
        const gameTips = [
            "画面をタッチまたはクリックすると、マーカーを設置できます。", "マーカーは3秒で自動的に消滅します。", "ロケットは、マーカーを結んだ中心点に移動します。",
            "画面の横幅が広いほど、ロケットやシャボンは速くなります。", "スキルを使うと、スコアが増えます。", "SpeedBoost：マーカーを２つ以上設置するとチャージ開始します。",
            "AllEraser：マーカーを１つ以上設置するとチャージ開始します。", "DokkanBomb：マーカーを３つ以上設置するとチャージ開始します。", "スマホなら縦画面、横画面でゲームの感触が変わります。",
            "PCなら、ウィンドウのアスペクト比を変えてみるとゲームの感触が変わります。", "シャボンは、たまに曲がったりします。", "マーカーは3つまで設置できます。設置するほどスコアが伸びます。",
            "マーカーが多いほど、強力なスキルをチャージできます。", "SpeedBoost：一定時間ロケットが加速します。", "AllEraser：設置したマーカーを全て消去します。",
            "DokkanBomb：画面内のシャボンを全て消去します。", "長時間プレイすると、より多くのシャボンが出現します。", "5分経過するごとに残機が1つ回復します。", "PCではA, S, Dキーでスキルを発動できます。",
            "45秒に一度、ステージにパワースポットが出現します。", "青いパワースポットはシャボンを全消去！", "黄色いパワースポットはスコアを1.3倍！", "緑のパワースポットは残機が1回復！"
        ];

        let gameState = GAME_STATE.TITLE;
        let lastTime = 0, deltaTime = 0, totalElapsedTime = 0, scaleFactor;
        let player = { x: 0, y: 0, radius: initialPlayerRadius, speed: 0, isInvincible: false, invincibleTimer: 0, boostTimer: 0, isBoosting: false, rotation: 0 };
        let markers = [], rocks = [], powerSpots = [], highScores = [];
        let score = 0, lives = 3;
        let gameStartTime = 0, lifeRecoveryTime = 0, lastRockSpawnTime = 0, lastPowerSpotSpawnTime = 0;
        const skillData = {
            eraser: { cost: 100, currentCost: 70, charge: 0, chargeCondition: 1, useCount: 0 },
            boost: { cost: 130, currentCost: 100, charge: 0, chargeCondition: 2, useCount: 0 },
            bomb: { cost: 150, currentCost: 130, charge: 0, chargeCondition: 3, useCount: 0 }
        };
        let audioContext, isSEEnabled = true, isBGMEnabled = true, bgmSource;
        const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim();

        function playSE(frequency, duration, type = 'sine') {
            if (!isSEEnabled) return;
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator(), gainNode = audioContext.createGain();
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration / 1000);
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        const difficultySettings = {
            initial: { rockSpawnRate: 2000, rockChances: { size: { normal: 80, big: 15, superBig: 5 }, speed: { normal: 50, slow: 20, fast: 20, verySlow: 10 }, moveType: { normal: 78, chase: 5, superChase: 1, lCurve: 8, rCurve: 8 }}},
            min1: { rockSpawnRate: 1500, rockChances: { size: { normal: 70, big: 20, superBig: 10 }, speed: { normal: 40, slow: 15, fast: 30, verySlow: 15 }, moveType: { normal: 62, chase: 8, superChase: 5, lCurve: 10, rCurve: 10 }}},
            min5: { rockSpawnRate: 1000, rockChances: { size: { normal: 60, big: 25, superBig: 15 }, speed: { normal: 30, slow: 10, fast: 40, verySlow: 20 }, moveType: { normal: 62, chase: 8, superChase: 10, lCurve: 10, rCurve: 10 }}},
            min10: { rockSpawnRate: 750, rockChances: { size: { normal: 50, big: 30, superBig: 20 }, speed: { normal: 20, slow: 5, fast: 50, verySlow: 25 }, moveType: { normal: 55, chase: 10, superChase: 10, lCurve: 15, rCurve: 15 }}}
        };
        let currentDifficulty = difficultySettings.initial;
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            scaleFactor = Math.min(canvas.width, canvas.height) / 600;
            player.speed = (canvas.width / 6) / 1000;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
        }

        const titleScreenMasterClickHandler = (event) => {
            if (event.target.closest('#settings-button-title')) {
                showSettingsModal();
            } else {
                startGame();
            }
        };

        function init() {
            resizeCanvas();
            loadHighScores();
            
            window.addEventListener('resize', resizeCanvas);
            titleScreen.addEventListener('click', titleScreenMasterClickHandler);

            pauseButton.addEventListener('click', showPauseModal);
            closeSettingsButton.addEventListener('click', closeSettingsModal);
            gameOverReturnButton.addEventListener('click', showTitleScreen);
            
            seToggle.addEventListener('change', () => { isSEEnabled = seToggle.checked; playSE(440, 100, 'square'); });
            bgmToggle.addEventListener('change', () => {
                isBGMEnabled = bgmToggle.checked;
                if (isBGMEnabled) {
                    if (bgmSource) bgmSource.start();
                    else createBGM();
                } else {
                    if (bgmSource) bgmSource.stop();
                }
            });

            skillEraserBtn.addEventListener('click', () => useSkill('eraser'));
            skillBoostBtn.addEventListener('click', () => useSkill('boost'));
            skillBombBtn.addEventListener('click', () => useSkill('bomb'));
            
            window.addEventListener('keydown', (event) => {
                if (gameState !== GAME_STATE.PLAYING) return;
                switch (event.key.toLowerCase()) {
                    case 'a': if (!skillEraserBtn.disabled) useSkill('eraser'); break;
                    case 's': if (!skillBoostBtn.disabled) useSkill('boost'); break;
                    case 'd': if (!skillBombBtn.disabled) useSkill('bomb'); break;
                }
            });
            
            document.addEventListener('visibilitychange', handleVisibilityChange);
        }

        function createBGM() {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (bgmSource) bgmSource.stop();
            const bufferSize = audioContext.sampleRate * 5;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.1;
            bgmSource = audioContext.createBufferSource();
            bgmSource.buffer = buffer;
            bgmSource.loop = true;
            bgmSource.connect(audioContext.destination);
            if (isBGMEnabled) bgmSource.start();
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                if (gameState === GAME_STATE.PLAYING) {
                    gameState = GAME_STATE.PAUSED;
                    lastTime = 0;
                }
            } else {
                if (gameState === GAME_STATE.PAUSED && !pauseModalOverlay.classList.contains('visible')) {
                    gameState = GAME_STATE.PLAYING;
                    lastTime = performance.now();
                }
            }
        }

        function handleGameCanvasTap(event) {
            event.preventDefault();
            if (gameState === GAME_STATE.PLAYING) {
                const rect = canvas.getBoundingClientRect();
                let x, y;
                if (event.type === 'touchstart') {
                    x = event.touches[0].clientX - rect.left;
                    y = event.touches[0].clientY - rect.top;
                } else {
                    x = event.clientX - rect.left;
                    y = event.clientY - rect.top;
                }
                if (event.target.id === 'gameCanvas' || event.target.closest('#game-ui') === null) {
                    if (markers.length < 3) {
                        markers.push({ x, y, remainingTime: 3000 });
                        playSE(660, 50, 'triangle');
                        score += 10;
                    }
                }
            }
        }
        
        function startGame() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            if (!bgmSource && isBGMEnabled) {
                createBGM();
            }

            titleScreen.removeEventListener('click', titleScreenMasterClickHandler);
            
            canvas.addEventListener('mousedown', handleGameCanvasTap);
            canvas.addEventListener('touchstart', handleGameCanvasTap);
            
            titleScreen.classList.add('fade-out');
            setTimeout(() => {
                titleScreen.style.display = 'none';
                gameUI.style.opacity = '1';
                gameUI.classList.add('is-active');
            }, 1000);
            
            gameState = GAME_STATE.PLAYING;
            gameStartTime = performance.now();
            lifeRecoveryTime = gameStartTime;
            lastRockSpawnTime = gameStartTime;
            lastPowerSpotSpawnTime = gameStartTime;
            lastTime = gameStartTime;
            totalElapsedTime = 0;
            
            playSE(880, 200, 'sine');
        }

        function showPauseModal() {
            if (gameState === GAME_STATE.PLAYING) {
                gameState = GAME_STATE.PAUSED;
                pauseModalOverlay.classList.add('visible');
                lastTime = 0; 
                const pauseModalContent = document.getElementById('pause-modal');
                pauseModalContent.innerHTML = `
                    <h2 class="modal-title">一時停止</h2>
                    <div class="toggle-switch-container"><label>SE</label><label class="toggle-switch"><input type="checkbox" id="se-toggle-pause"><span class="slider"></span></label></div>
                    <div class="toggle-switch-container"><label>BGM</label><label class="toggle-switch"><input type="checkbox" id="bgm-toggle-pause"><span class="slider"></span></label></div>
                    <div class="modal-buttons"><button class="modal-button" id="resume-button-temp">再開</button><button class="modal-button" id="game-end-button-temp">ゲーム終了</button></div>`;
                const seTogglePause = document.getElementById('se-toggle-pause'), bgmTogglePause = document.getElementById('bgm-toggle-pause');
                seTogglePause.checked = isSEEnabled; bgmTogglePause.checked = isBGMEnabled;
                seTogglePause.addEventListener('change', () => { isSEEnabled = seTogglePause.checked; seToggle.checked = isSEEnabled; playSE(440, 100, 'square'); });
                bgmTogglePause.addEventListener('change', () => { 
                    isBGMEnabled = bgmTogglePause.checked; bgmToggle.checked = isBGMEnabled;
                    if (isBGMEnabled) { if (bgmSource) bgmSource.start(); } else { if (bgmSource) bgmSource.stop(); }
                });
                document.getElementById('resume-button-temp').addEventListener('click', resumeGame);
                document.getElementById('game-end-button-temp').addEventListener('click', showTitleScreen);
                playSE(440, 100, 'square');
            }
        }
        
        function resumeGame() {
            gameState = GAME_STATE.PLAYING;
            pauseModalOverlay.classList.remove('visible');
            lastTime = performance.now();
            playSE(440, 100, 'square');
        }

        function showSettingsModal() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            settingsModalOverlay.classList.add('visible');
            playSE(440, 100, 'square');
        }

        function closeSettingsModal() {
            settingsModalOverlay.classList.remove('visible');
            playSE(440, 100, 'square');
        }
        
        function gameOver() {
            playSE(110, 500, 'sawtooth');
            gameState = GAME_STATE.GAME_OVER;
            const startRadius = player.radius;
            let animationTimer = 0;
            const animationDuration = 1000;
            function animateGameOver() {
                const elapsed = performance.now() - animationTimer;
                if (elapsed < animationDuration) {
                    const progress = elapsed / animationDuration;
                    player.radius = startRadius * (1 + progress * 2);
                    player.alpha = 1 - progress;
                    requestAnimationFrame(animateGameOver);
                } else {
                    gameUI.style.opacity = '0';
                    setTimeout(() => {
                        gameUI.style.pointerEvents = 'none';
                        gameOverModalOverlay.classList.add('visible');
                        gameOverTimeDisplay.textContent = formatTime(totalElapsedTime / 1000);
                        gameOverScoreDisplay.textContent = Math.floor(score).toString();
                        const randomIndex = Math.floor(Math.random() * gameTips.length);
                        gameOverTipsDisplay.textContent = `Tips: ${gameTips[randomIndex]}`;
                        gameOverSkillUsageDisplay.innerHTML = '';
                        if (skillData.eraser.useCount > 0) gameOverSkillUsageDisplay.innerHTML += `<div class="skill-usage-item"><i class="fas fa-eraser skill-usage-icon" style="color:${secondaryColor};"></i><span>${skillData.eraser.useCount}</span></div>`;
                        if (skillData.boost.useCount > 0) gameOverSkillUsageDisplay.innerHTML += `<div class="skill-usage-item"><i class="fas fa-fire-extinguisher skill-usage-icon" style="color:${secondaryColor};"></i><span>${skillData.boost.useCount}</span></div>`;
                        if (skillData.bomb.useCount > 0) gameOverSkillUsageDisplay.innerHTML += `<div class="skill-usage-item"><i class="fas fa-bomb skill-usage-icon" style="color:${secondaryColor};"></i><span>${skillData.bomb.useCount}</span></div>`;
                        saveHighScores(); loadHighScores();
                    }, 500);
                }
            }
            animationTimer = performance.now();
            animateGameOver();
        }

        function showTitleScreen() {
            score = 0; lives = 3; rocks = []; markers = []; powerSpots = [];
            Object.values(skillData).forEach(skill => { skill.charge = 0; skill.currentCost = skill.cost; skill.useCount = 0; });
            player = { ...player, x: canvas.width / 2, y: canvas.height / 2, isInvincible: false, isBoosting: false, boostTimer: 0, radius: initialPlayerRadius };
            
            gameState = GAME_STATE.TITLE;
            titleScreen.classList.remove('fade-out');
            titleScreen.style.display = 'flex';
            
            canvas.removeEventListener('mousedown', handleGameCanvasTap);
            canvas.removeEventListener('touchstart', handleGameCanvasTap);
            
            titleScreen.addEventListener('click', titleScreenMasterClickHandler);
            
            [settingsModalOverlay, pauseModalOverlay, gameOverModalOverlay].forEach(el => el.classList.remove('visible'));
            
            gameUI.style.opacity = '0';
            gameUI.classList.remove('is-active');
            
            gameOverTipsDisplay.textContent = "";
        }

        function calculatePlayerTarget() {
            if (markers.length === 0) return null;
            if (markers.length === 1) return { x: markers[0].x, y: markers[0].y };
            if (markers.length === 2) return { x: (markers[0].x + markers[1].x) / 2, y: (markers[0].y + markers[1].y) / 2 };
            return { x: (markers[0].x + markers[1].x + markers[2].x) / 3, y: (markers[0].y + markers[1].y + markers[2].y) / 3 };
        }
        
        function updatePlayer() {
            const target = calculatePlayerTarget();
            if (target) {
                const dx = target.x - player.x, dy = target.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                let currentSpeed = player.speed * (player.isBoosting ? 1.5 : 1);
                if (distance > 4) {
                    const ratio = (currentSpeed * deltaTime) / distance;
                    player.x += dx * ratio; player.y += dy * ratio;
                    player.rotation = Math.atan2(dy, dx);
                } else {
                    player.x = target.x; player.y = target.y;
                }
            }
        }
        
        // ▼▼▼▼▼ 修正箇所1: spawnRock関数 ▼▼▼▼▼
        function spawnRock() {
            const { size, speed, moveType } = getRandomRockChances(currentDifficulty.rockChances);
            let rock = {
                x: 0, y: 0, radius: canvas.width * 0.05 * size.multiplier,
                speed: player.speed * speed.multiplier, moveType: moveType.type,
                rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.05,
                angle: 0, lastCorrection: performance.now()
            };

            // 固定のオフセット値(50)の代わりに、生成される岩の半径をオフセットとして使用
            const spawnOffset = rock.radius; 
            const edge = Math.floor(Math.random() * 4);
            const bufferX = canvas.width + spawnOffset * 2;
            const bufferY = canvas.height + spawnOffset * 2;

            switch (edge) {
                case 0: // 上から出現
                    rock.x = Math.random() * bufferX - spawnOffset; 
                    rock.y = -spawnOffset; 
                    break;
                case 1: // 右から出現
                    rock.x = canvas.width + spawnOffset;
                    rock.y = Math.random() * bufferY - spawnOffset; 
                    break;
                case 2: // 下から出現
                    rock.x = Math.random() * bufferX - spawnOffset; 
                    rock.y = canvas.height + spawnOffset; 
                    break;
                case 3: // 左から出現
                    rock.x = -spawnOffset; 
                    rock.y = Math.random() * bufferY - spawnOffset;
                    break;
            }

            let targetX, targetY;
            if (['chase', 'superChase'].includes(rock.moveType)) { targetX = player.x; targetY = player.y; }
            else { targetX = Math.random() * canvas.width; targetY = Math.random() * canvas.height; }
            rock.angle = Math.atan2(targetY - rock.y, targetX - rock.x);
            rocks.push(rock);
        }
        // ▲▲▲▲▲ 修正箇所1: ここまで ▲▲▲▲▲

        function getRandomRockChances(chances) {
            const randomPick = (options) => {
                const rand = Math.random() * 100;
                let cumulative = 0;
                for (const key in options) {
                    cumulative += options[key];
                    if (rand < cumulative) return key;
                }
                return Object.keys(options)[0];
            };
            const sizeType = randomPick(chances.size), speedType = randomPick(chances.speed), moveType = randomPick(chances.moveType);
            const sizeMap = { normal: { multiplier: 1 }, big: { multiplier: 1.5 }, superBig: { multiplier: 2 } };
            const speedMap = { normal: { multiplier: 0.8 }, slow: { multiplier: 0.7 * 0.8 }, fast: { multiplier: 1 }, verySlow: { multiplier: 0.5 * 0.8 } };
            const moveTypeMap = { normal: { type: 'normal' }, chase: { type: 'chase' }, superChase: { type: 'superChase' }, lCurve: { type: 'lCurve' }, rCurve: { type: 'rCurve' } };
            return { size: sizeMap[sizeType], speed: speedMap[speedType], moveType: moveTypeMap[moveType] };
        }
        
        // ▼▼▼▼▼ 修正箇所2: updateRocks関数 ▼▼▼▼▼
        function updateRocks() {
            const now = performance.now();
            rocks = rocks.filter(rock => {
                const angleCorrection = (correctionRate, threshold) => {
                    if (now - rock.lastCorrection > threshold) {
                        const targetAngle = Math.atan2(player.y - rock.y, player.x - rock.x);
                        let diff = targetAngle - rock.angle;
                        if (diff > Math.PI) diff -= Math.PI * 2; if (diff < -Math.PI) diff += Math.PI * 2;
                        rock.angle += Math.sign(diff) * Math.min(Math.abs(diff), correctionRate);
                        rock.lastCorrection = now;
                    }
                };
                if (rock.moveType === 'chase') angleCorrection(4 * Math.PI / 180, 700);
                else if (rock.moveType === 'superChase') angleCorrection(4 * Math.PI / 180, 350);
                else if (rock.moveType === 'lCurve' && now - rock.lastCorrection > 700) { rock.angle -= 15 * Math.PI / 180; rock.lastCorrection = now; }
                else if (rock.moveType === 'rCurve' && now - rock.lastCorrection > 700) { rock.angle += 15 * Math.PI / 180; rock.lastCorrection = now; }
                rock.x += Math.cos(rock.angle) * rock.speed * deltaTime;
                rock.y += Math.sin(rock.angle) * rock.speed * deltaTime;
                rock.rotation += rock.rotationSpeed;

                // 消滅判定を、固定値(-100, +100)ではなく、岩の半径を基に行う
                return !(rock.x < -rock.radius || rock.x > canvas.width + rock.radius || rock.y < -rock.radius || rock.y > canvas.height + rock.radius);
            });
        }
        // ▲▲▲▲▲ 修正箇所2: ここまで ▲▲▲▲▲
        
        function checkCollision(obj1, obj2) {
            const dx = obj1.x - obj2.x, dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy) < obj1.radius + obj2.radius;
        }

        function updateSkills() {
            const elapsedTime = deltaTime / 1000, numMarkers = markers.length;
            if (numMarkers >= skillData.eraser.chargeCondition) skillData.eraser.charge = Math.min(skillData.eraser.currentCost, skillData.eraser.charge + 10 * elapsedTime);
            if (numMarkers >= skillData.boost.chargeCondition) skillData.boost.charge = Math.min(skillData.boost.currentCost, skillData.boost.charge + 10 * elapsedTime);
            if (numMarkers >= skillData.bomb.chargeCondition) skillData.bomb.charge = Math.min(skillData.bomb.currentCost, skillData.bomb.charge + 10 * elapsedTime);
            ['eraser', 'boost', 'bomb'].forEach(updateSkillButton);
            if (player.isBoosting) {
                player.boostTimer -= deltaTime;
                if (player.boostTimer <= 0) player.isBoosting = false;
            }
        }
        
        function updateSkillButton(skillName) {
            const btn = document.getElementById(`skill-${skillName}`), meter = btn.querySelector('.charge-meter'), skill = skillData[skillName];
            const progress = skill.charge / skill.currentCost;
            if (progress >= 1) { btn.classList.add('ready'); btn.disabled = false; } else { btn.classList.remove('ready'); btn.disabled = true; }
            meter.style.background = `conic-gradient(${secondaryColor} ${360 * progress}deg, transparent ${360 * progress}deg)`;
        }

        function useSkill(skillName) {
            const skill = skillData[skillName];
            if (skill.charge >= skill.currentCost) {
                playSE(770, 100, 'square');
                skill.charge = 0; skill.useCount++; score += getSkillBonus(skillName); skill.currentCost += skill.cost;
                if (skillName === 'eraser') markers = [];
                else if (skillName === 'boost') { player.isBoosting = true; player.boostTimer = 10000; }
                else if (skillName === 'bomb') { rocks = []; playSE(100, 50, 'triangle'); }
                updateSkillButton(skillName);
            }
        }
        
        function getSkillBonus(skillName) { return { eraser: 56, boost: 555, bomb: 1000 }[skillName] || 0; }

        function updateUI() {
            currentScoreDisplay.textContent = Math.floor(score).toString();
            gameTimeDisplay.textContent = formatTime(totalElapsedTime / 1000);
            livesDisplay.innerHTML = Array(lives).fill('<i class="fas fa-rocket life-icon"></i>').join('');
            const elapsed = totalElapsedTime / 1000;
            if (elapsed >= 360) currentDifficulty = difficultySettings.min10;
            else if (elapsed >= 180) currentDifficulty = difficultySettings.min5;
            else if (elapsed >= 60) currentDifficulty = difficultySettings.min1;
            else currentDifficulty = difficultySettings.initial;
            if (lives < 3 && performance.now() - lifeRecoveryTime > 300000) {
                lives++; lifeRecoveryTime = performance.now(); playSE(440, 300, 'sine');
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawRocks(); drawMarkers(); drawPowerSpots(); drawPlayer();
        }
        
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.rotation + Math.PI / 2);
            if (player.isInvincible && Math.floor(performance.now() / 100) % 2 === 0) { ctx.restore(); return; }
            ctx.fillStyle = player.isBoosting ? '#42a5f5' : secondaryColor;
            ctx.beginPath();
            ctx.moveTo(0, -player.radius * 2);
            ctx.lineTo(-player.radius, player.radius * 2);
            ctx.lineTo(player.radius, player.radius * 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        function drawMarkers() {
            markers.forEach(marker => {
                const progress = 1 - (marker.remainingTime / 3000);
                ctx.beginPath(); ctx.arc(marker.x, marker.y, 8 * scaleFactor, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 255, 255, ${1 - progress})`; ctx.fill();
                ctx.beginPath(); ctx.arc(marker.x, marker.y, 12 * scaleFactor, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * (1 - progress));
                ctx.strokeStyle = `rgba(255, 255, 255, 0.5)`; ctx.lineWidth = 2; ctx.stroke();
            });
        }
        
        function drawRocks() {
            rocks.forEach(rock => {
                ctx.save();
                ctx.translate(rock.x, rock.y);
                ctx.rotate(rock.rotation);
                if (rock.isVanishing) {
                    const progress = (1000 - rock.vanishTimer) / 1000;
                    ctx.globalAlpha = 1 - progress; ctx.scale(1 + progress * 2, 1 + progress * 2);
                }
                ctx.beginPath(); ctx.arc(0, 0, rock.radius, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.fill();
                ctx.restore();
            });
        }
        
        function animate(timestamp) {
            if (gameState === GAME_STATE.PLAYING) {
                if (lastTime === 0) lastTime = timestamp;
                deltaTime = timestamp - lastTime;
                lastTime = timestamp;
                update();
            }
            draw();
            requestAnimationFrame(animate);
        }

        function update() {
            totalElapsedTime += deltaTime;
            score += 10 * markers.length * (deltaTime / 1000);
            updatePlayer();
            markers.forEach(marker => marker.remainingTime -= deltaTime);
            markers = markers.filter(marker => marker.remainingTime > 0);
            if (performance.now() - lastRockSpawnTime > currentDifficulty.rockSpawnRate) {
                spawnRock();
                lastRockSpawnTime = performance.now();
            }
            if (performance.now() - lastPowerSpotSpawnTime > 45000) {
                spawnPowerSpot();
                lastPowerSpotSpawnTime = performance.now();
            }
            updateRocks();
            updatePowerSpots();
            if (!player.isInvincible) {
                rocks.forEach(rock => {
                    if (checkCollision(player, rock)) {
                        lives--;
                        playSE(220, 200, 'sawtooth');
                        if (lives <= 0) gameOver();
                        else { player.isInvincible = true; player.invincibleTimer = 2000; }
                    }
                });
            } else {
                player.invincibleTimer -= deltaTime;
                if (player.invincibleTimer <= 0) player.isInvincible = false;
            }
            updateSkills();
            updateUI();
        }

        function spawnPowerSpot() {
            if (powerSpots.length > 0) return;
            const types = ['blue', 'yellow', 'green'], type = types[Math.floor(Math.random() * types.length)];
            const colorMap = { blue: 'rgba(64, 128, 255, 0.8)', yellow: 'rgba(255, 248, 152, 0.8)', green: 'rgba(64, 255, 64, 0.8)' };
            const padding = 50, x = Math.random() * (canvas.width - padding * 2) + padding, y = Math.random() * (canvas.height - padding * 2) + padding;
            powerSpots.push({ x, y, radius: player.radius * 2, type, color: colorMap[type], remainingTime: 8000 });
        }

        function updatePowerSpots() {
            powerSpots = powerSpots.filter(ps => {
                ps.remainingTime -= deltaTime;
                if (checkCollision(player, ps)) {
                    playSE(550, 150, 'triangle');
                    activatePowerSpotEffect(ps);
                    return false;
                }
                return ps.remainingTime > 0;
            });
        }

        function activatePowerSpotEffect(powerSpot) {
            switch (powerSpot.type) {
                case 'blue': rocks = []; break;
                case 'yellow': score = Math.floor(score * 1.3); break;
                case 'green': if (lives < 3) lives++; break;
            }
        }

        function drawPowerSpots() {
            powerSpots.forEach(ps => {
                ctx.save();
                ctx.globalAlpha = (ps.remainingTime < 2000 && Math.floor(performance.now() / 150) % 2 === 0) ? 0.5 : 1.0;
                ctx.beginPath(); ctx.arc(ps.x, ps.y, ps.radius, 0, Math.PI * 2); ctx.fillStyle = ps.color; ctx.fill();
                ctx.beginPath(); ctx.arc(ps.x, ps.y, ps.radius * 1.2, 0, Math.PI * 2); ctx.strokeStyle = ps.color; ctx.lineWidth = 2; ctx.stroke();
                ctx.restore();
            });
        }
        
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        function saveHighScores() {
            highScores.push(Math.floor(score));
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 3);
            localStorage.setItem('highScores', JSON.stringify(highScores));
        }

        function loadHighScores() {
            const savedScores = localStorage.getItem('highScores');
            if (savedScores) highScores = JSON.parse(savedScores);
            else highScores = [0, 0, 0];
            highScoresList.forEach((el, index) => {
                el.textContent = highScores[index] ? `${index + 1}. ${highScores[index]}` : `${index + 1}. ---`;
            });
        }
        
        window.onload = function() {
            init();
            animate(0);
        };

    </script>
</body>
</html>
